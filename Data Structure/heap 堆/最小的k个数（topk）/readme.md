**1. heap (堆)**

   a) 求最小k个数，用最大堆（或者取负数再用最小堆）
   
   b) 求最大k个数，用最小堆
   
   heap的语法：https://blog.csdn.net/qq_23869697/article/details/82735088
   
   heapq.heappush(heap, item)
    往堆中插入一个值，同时要保持为最小堆。

    heapq.heappop(heap)
    返回堆中的最小值，并把它从堆中删除，同时保持为最小堆；如果堆为空，发生 IndexError。直接通过heap[0]可以获取最小值并不从堆中把它删除。

    heapq.heappushpop(heap, item)
    向堆中插入值后再弹出堆中的最小值，这个函数的速度比直接使用heappush() 和heappop()的效率更加高。

    heapq.heapreplace(heap, item)
    弹出和返回堆中的最小值再插入一个新的值。堆的大小没有改变。如果堆为空，产生 IndexError。
    这一个操作也比直接使用heappush() 和heappop()的效率更加高，尤其适合使用在固定堆大小不变的情况。
    与上一个函数相比，这个函数返回的值可能要比将要插入到堆的值大。

    heapq.heapify(x)
    将一个list转为最小堆，线性时间复杂度，O(n).

**2. 快排**

若 k = m，我们就找到了最小的 kk 个数，就是左侧的数组；

若 k<m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；

若 k>m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m 个数，对右侧数组递归地 partition 即可。



**两种方法的优劣性比较**

在面试中，另一个常常问的问题就是这两种方法有何优劣。看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：

第一，算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。

第二，算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。

